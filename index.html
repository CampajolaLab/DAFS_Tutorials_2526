<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Book Mechanics - Trading Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00d4ff;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #16213e;
            border: 2px solid #0f3460;
            border-radius: 8px;
            padding: 20px;
        }

        .panel h2 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #0f3460;
            padding-bottom: 10px;
        }

        .order-book {
            font-size: 0.95em;
        }

        .order-book-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 8px;
            background: #0f3460;
            font-weight: bold;
            margin-bottom: 5px;
            border-radius: 4px;
        }

        .order-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 6px 8px;
            margin: 2px 0;
            border-radius: 3px;
        }

        .bid-row {
            background: rgba(0, 255, 100, 0.1);
        }

        .ask-row {
            background: rgba(255, 50, 50, 0.1);
        }

        .bid-price {
            color: #00ff64;
            font-weight: bold;
        }

        .ask-price {
            color: #ff3232;
            font-weight: bold;
        }

        .spread-row {
            text-align: center;
            padding: 10px;
            color: #888;
            font-style: italic;
            margin: 5px 0;
        }

        .input-group {
            margin: 15px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #00d4ff;
            font-weight: bold;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 10px;
            background: #0f3460;
            border: 1px solid #00d4ff;
            color: #eee;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
        }

        button {
            background: #00d4ff;
            color: #16213e;
            border: none;
            padding: 12px 24px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-size: 1em;
            margin: 5px 5px 5px 0;
            transition: all 0.3s;
        }

        button:hover {
            background: #00a8cc;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.cancel-btn {
            background: #ff3232;
            color: white;
        }

        button.cancel-btn:hover {
            background: #cc0000;
        }

        .positions-table {
            margin-top: 10px;
        }

        .position-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            padding: 8px;
            margin: 3px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .position-header {
            font-weight: bold;
            background: #0f3460;
            color: #00d4ff;
        }

        .profit {
            color: #00ff64;
        }

        .loss {
            color: #ff3232;
        }

        .info-box {
            background: rgba(0, 212, 255, 0.1);
            border-left: 4px solid #00d4ff;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: rgba(255, 50, 50, 0.1);
            border-left: 4px solid #ff3232;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .success-box {
            background: rgba(0, 255, 100, 0.1);
            border-left: 4px solid #00ff64;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .player-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        .sibling-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .sibling-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 4px;
            font-weight: bold;
        }

        .sibling-hidden {
            background: rgba(255, 255, 255, 0.05);
            color: #555;
        }

        #message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 4px;
            font-weight: bold;
            display: none;
            z-index: 1000;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .admin-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .order-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .my-order {
            border-left: 3px solid #00d4ff;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Order Book Trading Game</h1>

        <div id="message"></div>

        <div class="main-grid">
            <!-- Admin Panel -->
            <div class="panel">
                <h2>üîß Admin Panel</h2>
                <div class="info-box">
                    <strong>Game Setup:</strong> Enter player names and their sibling counts. Reveal counts one by one during gameplay.
                </div>
                
                <div class="input-group">
                    <label>Player Name:</label>
                    <input type="text" id="playerName" placeholder="Enter player name">
                </div>
                
                <div class="input-group">
                    <label>Sibling Count:</label>
                    <input type="number" id="siblingCount" min="0" placeholder="Number of siblings">
                </div>
                
                <button onclick="addPlayer()">‚ûï Add Player</button>
                <button onclick="resetGame()">üîÑ Reset Game</button>
                <button onclick="settleContract()">üí∞ Settle Contract</button>
                
                <div class="sibling-list" id="siblingList"></div>
            </div>

            <!-- Order Book -->
            <div class="panel">
                <h2>üìñ Order Book</h2>
                <div class="info-box">
                    <strong>Rule:</strong> You must either improve the best bid/offer or trade against existing orders.
                </div>
                
                <div class="order-book">
                    <div class="order-book-header">
                        <div>Price</div>
                        <div>Size</div>
                        <div>Player</div>
                    </div>
                    <div id="orderBookDisplay"></div>
                </div>
            </div>

            <!-- Player Controls -->
            <div class="panel">
                <h2>üéÆ Player Controls</h2>
                
                <div class="input-group">
                    <label>Your Name:</label>
                    <input type="text" id="myPlayerName" placeholder="Enter your name">
                </div>
                
                <div class="input-group">
                    <label>Order Type:</label>
                    <select id="orderType">
                        <option value="bid">Bid (Buy)</option>
                        <option value="ask">Ask (Sell)</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Price:</label>
                    <input type="number" id="orderPrice" step="0.01" placeholder="Order price">
                </div>
                
                <div class="input-group">
                    <label>Size:</label>
                    <input type="number" id="orderSize" min="1" value="1" placeholder="Order size">
                </div>
                
                <button onclick="submitOrder()">üì§ Submit Order</button>
                <button onclick="cancelMyOrders()" class="cancel-btn">‚ùå Cancel My Orders</button>
                
                <div class="player-info">
                    <div class="stat">
                        <div class="stat-label">Position</div>
                        <div class="stat-value" id="myPosition">0</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">P&L</div>
                        <div class="stat-value" id="myPnL">$0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Positions Panel -->
        <div class="panel">
            <h2>üìä All Player Positions</h2>
            <div class="positions-table" id="positionsTable"></div>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            players: {},           // { playerName: { siblingCount: X, revealed: false } }
            orders: [],            // Array of order objects
            trades: [],            // Array of executed trades
            positions: {},         // { playerName: { quantity: X, avgPrice: Y, realizedPnL: Z } }
            orderIdCounter: 1,
            settledPrice: null
        };

        // Load state from localStorage
        function loadState() {
            const saved = localStorage.getItem('orderBookGame');
            if (saved) {
                try {
                    gameState = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading state:', e);
                }
            }
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('orderBookGame', JSON.stringify(gameState));
        }

        // Polling for multi-device sync (check every 2 seconds)
        setInterval(() => {
            loadState();
            updateDisplay();
        }, 2000);

        // Add player with sibling count
        function addPlayer() {
            const name = document.getElementById('playerName').value.trim();
            const count = parseInt(document.getElementById('siblingCount').value);

            if (!name) {
                showMessage('Please enter a player name', 'error');
                return;
            }
            
            if (isNaN(count) || count < 0) {
                showMessage('Please enter a valid sibling count', 'error');
                return;
            }

            gameState.players[name] = {
                siblingCount: count,
                revealed: false
            };

            // Initialize position if not exists
            if (!gameState.positions[name]) {
                gameState.positions[name] = {
                    quantity: 0,
                    totalCost: 0,
                    realizedPnL: 0
                };
            }

            saveState();
            updateDisplay();
            
            document.getElementById('playerName').value = '';
            document.getElementById('siblingCount').value = '';
            
            showMessage(`Player ${name} added with ${count} siblings`, 'success');
        }

        // Toggle reveal sibling count
        function toggleReveal(playerName) {
            if (gameState.players[playerName]) {
                gameState.players[playerName].revealed = !gameState.players[playerName].revealed;
                saveState();
                updateDisplay();
            }
        }

        // Get best bid and ask
        function getBestBidAsk() {
            const bids = gameState.orders.filter(o => o.side === 'bid').sort((a, b) => b.price - a.price);
            const asks = gameState.orders.filter(o => o.side === 'ask').sort((a, b) => a.price - b.price);
            
            return {
                bestBid: bids.length > 0 ? bids[0].price : null,
                bestAsk: asks.length > 0 ? asks[0].price : null
            };
        }

        // Check if order tightens the spread or trades
        function canPlaceOrder(side, price) {
            const { bestBid, bestAsk } = getBestBidAsk();
            
            if (side === 'bid') {
                // Bid must be higher than current best bid OR cross the spread to trade
                if (bestBid === null) return true; // No bids exist
                if (price > bestBid) return true;  // Tightens spread
                if (bestAsk !== null && price >= bestAsk) return true; // Will trade
                return false;
            } else {
                // Ask must be lower than current best ask OR cross the spread to trade
                if (bestAsk === null) return true; // No asks exist
                if (price < bestAsk) return true;  // Tightens spread
                if (bestBid !== null && price <= bestBid) return true; // Will trade
                return false;
            }
        }

        // Execute trades when orders cross
        function matchOrders(newOrder) {
            const trades = [];
            let remainingSize = newOrder.size;

            // Get opposite side orders that cross with new order
            const oppositeOrders = gameState.orders
                .filter(o => o.side !== newOrder.side)
                .filter(o => {
                    if (newOrder.side === 'bid') {
                        return o.price <= newOrder.price; // Bid crosses asks at or below bid price
                    } else {
                        return o.price >= newOrder.price; // Ask crosses bids at or above ask price
                    }
                })
                .sort((a, b) => {
                    // Price-time priority
                    if (newOrder.side === 'bid') {
                        return a.price - b.price || a.id - b.id; // Best ask first
                    } else {
                        return b.price - a.price || a.id - b.id; // Best bid first
                    }
                });

            for (let order of oppositeOrders) {
                if (remainingSize <= 0) break;

                const tradeSize = Math.min(remainingSize, order.size);
                const tradePrice = order.price; // Passive order price

                // Create trade
                const trade = {
                    id: gameState.trades.length + 1,
                    buyer: newOrder.side === 'bid' ? newOrder.player : order.player,
                    seller: newOrder.side === 'bid' ? order.player : newOrder.player,
                    price: tradePrice,
                    size: tradeSize,
                    timestamp: Date.now()
                };

                trades.push(trade);
                gameState.trades.push(trade);

                // Update positions
                updatePosition(trade.buyer, tradeSize, tradePrice);
                updatePosition(trade.seller, -tradeSize, tradePrice);

                // Reduce order sizes
                order.size -= tradeSize;
                remainingSize -= tradeSize;

                // Remove filled orders
                if (order.size === 0) {
                    gameState.orders = gameState.orders.filter(o => o.id !== order.id);
                }
            }

            // Add remaining size to order book
            if (remainingSize > 0) {
                newOrder.size = remainingSize;
                gameState.orders.push(newOrder);
            }

            return trades;
        }

        // Update player position
        function updatePosition(player, quantity, price) {
            if (!gameState.positions[player]) {
                gameState.positions[player] = {
                    quantity: 0,
                    totalCost: 0,
                    realizedPnL: 0
                };
            }

            const pos = gameState.positions[player];
            
            if (quantity > 0) {
                // Buying
                pos.totalCost += quantity * price;
                pos.quantity += quantity;
            } else {
                // Selling
                const sellSize = Math.abs(quantity);
                
                if (pos.quantity > 0) {
                    // Have long position - realize P&L
                    const avgCost = pos.totalCost / pos.quantity;
                    const closedSize = Math.min(sellSize, pos.quantity);
                    const pnl = closedSize * (price - avgCost);
                    
                    pos.realizedPnL += pnl;
                    pos.quantity -= closedSize;
                    pos.totalCost -= closedSize * avgCost;
                    
                    // If selling more than position, go short
                    if (sellSize > closedSize) {
                        const shortSize = sellSize - closedSize;
                        pos.quantity -= shortSize;
                        pos.totalCost -= shortSize * price;
                    }
                } else {
                    // Short or flat - add to short
                    pos.quantity -= sellSize;
                    pos.totalCost -= sellSize * price;
                }
            }
        }

        // Submit order
        function submitOrder() {
            const playerName = document.getElementById('myPlayerName').value.trim();
            const side = document.getElementById('orderType').value;
            const price = parseFloat(document.getElementById('orderPrice').value);
            const size = parseInt(document.getElementById('orderSize').value);

            if (!playerName) {
                showMessage('Please enter your name', 'error');
                return;
            }

            if (isNaN(price) || price <= 0) {
                showMessage('Please enter a valid price', 'error');
                return;
            }

            if (isNaN(size) || size <= 0) {
                showMessage('Please enter a valid size', 'error');
                return;
            }

            // Check tighten or trade rule
            if (!canPlaceOrder(side, price)) {
                const { bestBid, bestAsk } = getBestBidAsk();
                showMessage(
                    `Order rejected! You must improve the best ${side} or trade. ` +
                    `Best bid: ${bestBid !== null ? bestBid.toFixed(2) : 'N/A'}, ` +
                    `Best ask: ${bestAsk !== null ? bestAsk.toFixed(2) : 'N/A'}`,
                    'error'
                );
                return;
            }

            // Initialize position if needed
            if (!gameState.positions[playerName]) {
                gameState.positions[playerName] = {
                    quantity: 0,
                    totalCost: 0,
                    realizedPnL: 0
                };
            }

            const order = {
                id: gameState.orderIdCounter++,
                player: playerName,
                side: side,
                price: price,
                size: size,
                timestamp: Date.now()
            };

            // Try to match orders
            const trades = matchOrders(order);

            saveState();
            updateDisplay();

            if (trades.length > 0) {
                showMessage(`Order executed! ${trades.length} trade(s) completed`, 'success');
            } else {
                showMessage(`Order placed in book at ${price.toFixed(2)}`, 'success');
            }

            // Clear price and size
            document.getElementById('orderPrice').value = '';
            document.getElementById('orderSize').value = '';
        }

        // Cancel player's orders
        function cancelMyOrders() {
            const playerName = document.getElementById('myPlayerName').value.trim();
            
            if (!playerName) {
                showMessage('Please enter your name', 'error');
                return;
            }

            const beforeCount = gameState.orders.length;
            gameState.orders = gameState.orders.filter(o => o.player !== playerName);
            const cancelled = beforeCount - gameState.orders.length;

            if (cancelled > 0) {
                saveState();
                updateDisplay();
                showMessage(`Cancelled ${cancelled} order(s)`, 'success');
            } else {
                showMessage('No orders to cancel', 'error');
            }
        }

        // Reset game
        function resetGame() {
            if (confirm('Are you sure you want to reset the entire game?')) {
                gameState = {
                    players: {},
                    orders: [],
                    trades: [],
                    positions: {},
                    orderIdCounter: 1,
                    settledPrice: null
                };
                saveState();
                updateDisplay();
                showMessage('Game reset!', 'success');
            }
        }

        // Settle contract at sum of all sibling counts
        function settleContract() {
            const totalSiblings = Object.values(gameState.players)
                .reduce((sum, p) => sum + p.siblingCount, 0);
            
            if (totalSiblings === 0) {
                showMessage('No players added yet!', 'error');
                return;
            }

            gameState.settledPrice = totalSiblings;
            
            // Mark all as realized
            for (let playerName in gameState.positions) {
                const pos = gameState.positions[playerName];
                if (pos.quantity !== 0) {
                    const avgPrice = pos.quantity > 0 ? pos.totalCost / pos.quantity : -pos.totalCost / Math.abs(pos.quantity);
                    const unrealizedPnL = pos.quantity * (totalSiblings - avgPrice);
                    pos.realizedPnL += unrealizedPnL;
                    pos.quantity = 0;
                    pos.totalCost = 0;
                }
            }

            saveState();
            updateDisplay();
            showMessage(`Contract settled at ${totalSiblings} (sum of all sibling counts)`, 'success');
        }

        // Calculate P&L for a player
        function calculatePnL(playerName) {
            const pos = gameState.positions[playerName];
            if (!pos) return { realized: 0, unrealized: 0, total: 0 };

            const realized = pos.realizedPnL;
            let unrealized = 0;

            if (pos.quantity !== 0 && gameState.settledPrice !== null) {
                const avgPrice = pos.quantity > 0 ? pos.totalCost / pos.quantity : -pos.totalCost / Math.abs(pos.quantity);
                unrealized = pos.quantity * (gameState.settledPrice - avgPrice);
            }

            return {
                realized: realized,
                unrealized: unrealized,
                total: realized + unrealized
            };
        }

        // Update all displays
        function updateDisplay() {
            updateSiblingList();
            updateOrderBook();
            updateMyPosition();
            updatePositionsTable();
        }

        // Update sibling list display
        function updateSiblingList() {
            const container = document.getElementById('siblingList');
            container.innerHTML = '';

            for (let playerName in gameState.players) {
                const player = gameState.players[playerName];
                const div = document.createElement('div');
                div.className = player.revealed ? 'sibling-item' : 'sibling-item sibling-hidden';
                div.textContent = player.revealed 
                    ? `${playerName}: ${player.siblingCount}` 
                    : `${playerName}: ???`;
                div.onclick = () => toggleReveal(playerName);
                div.style.cursor = 'pointer';
                div.title = 'Click to toggle reveal';
                container.appendChild(div);
            }
        }

        // Update order book display
        function updateOrderBook() {
            const container = document.getElementById('orderBookDisplay');
            container.innerHTML = '';

            const bids = gameState.orders
                .filter(o => o.side === 'bid')
                .sort((a, b) => b.price - a.price);
            
            const asks = gameState.orders
                .filter(o => o.side === 'ask')
                .sort((a, b) => a.price - b.price);

            const myName = document.getElementById('myPlayerName').value.trim();

            // Show asks (highest to lowest)
            for (let i = asks.length - 1; i >= 0; i--) {
                const order = asks[i];
                const div = document.createElement('div');
                div.className = 'order-row ask-row' + (order.player === myName ? ' my-order' : '');
                div.innerHTML = `
                    <div class="ask-price">${order.price.toFixed(2)}</div>
                    <div>${order.size}</div>
                    <div>${order.player}</div>
                `;
                container.appendChild(div);
            }

            // Show spread
            const { bestBid, bestAsk } = getBestBidAsk();
            const spread = (bestBid !== null && bestAsk !== null) 
                ? (bestAsk - bestBid).toFixed(2) 
                : 'N/A';
            
            const spreadDiv = document.createElement('div');
            spreadDiv.className = 'spread-row';
            spreadDiv.textContent = `--- Spread: ${spread} ---`;
            container.appendChild(spreadDiv);

            // Show bids (highest to lowest)
            for (let order of bids) {
                const div = document.createElement('div');
                div.className = 'order-row bid-row' + (order.player === myName ? ' my-order' : '');
                div.innerHTML = `
                    <div class="bid-price">${order.price.toFixed(2)}</div>
                    <div>${order.size}</div>
                    <div>${order.player}</div>
                `;
                container.appendChild(div);
            }

            if (gameState.orders.length === 0) {
                container.innerHTML = '<div class="spread-row">No orders in book</div>';
            }
        }

        // Update my position display
        function updateMyPosition() {
            const playerName = document.getElementById('myPlayerName').value.trim();
            const posElement = document.getElementById('myPosition');
            const pnlElement = document.getElementById('myPnL');

            if (!playerName || !gameState.positions[playerName]) {
                posElement.textContent = '0';
                pnlElement.textContent = '$0.00';
                pnlElement.className = 'stat-value';
                return;
            }

            const pos = gameState.positions[playerName];
            const pnl = calculatePnL(playerName);

            posElement.textContent = pos.quantity;
            pnlElement.textContent = `$${pnl.total.toFixed(2)}`;
            pnlElement.className = 'stat-value ' + (pnl.total >= 0 ? 'profit' : 'loss');
        }

        // Update positions table
        function updatePositionsTable() {
            const container = document.getElementById('positionsTable');
            container.innerHTML = `
                <div class="position-row position-header">
                    <div>Player</div>
                    <div>Position</div>
                    <div>P&L</div>
                </div>
            `;

            for (let playerName in gameState.positions) {
                const pos = gameState.positions[playerName];
                const pnl = calculatePnL(playerName);
                
                const div = document.createElement('div');
                div.className = 'position-row';
                div.innerHTML = `
                    <div>${playerName}</div>
                    <div>${pos.quantity}</div>
                    <div class="${pnl.total >= 0 ? 'profit' : 'loss'}">$${pnl.total.toFixed(2)}</div>
                `;
                container.appendChild(div);
            }

            if (gameState.settledPrice !== null) {
                const info = document.createElement('div');
                info.className = 'info-box';
                info.innerHTML = `<strong>Contract Settled at ${gameState.settledPrice}</strong> (sum of all sibling counts)`;
                container.appendChild(info);
            }
        }

        // Show message to user
        function showMessage(text, type = 'info') {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.display = 'block';
            
            if (type === 'error') {
                msg.style.background = '#ff3232';
                msg.style.color = 'white';
            } else if (type === 'success') {
                msg.style.background = '#00ff64';
                msg.style.color = '#16213e';
            } else {
                msg.style.background = '#00d4ff';
                msg.style.color = '#16213e';
            }

            setTimeout(() => {
                msg.style.display = 'none';
            }, 3000);
        }

        // Initialize on load
        loadState();
        updateDisplay();
    </script>
</body>
</html>
